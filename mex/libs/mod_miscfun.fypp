!****h* modules/miscfun
!
! NAME
!
! miscfun: provides miscellaneous useful functions.
!
! AUTHOR
!
! Laurent Hoeltgen <hoeltgen@b-tu.de>
!*****

! Copyright (C) 2015 Laurent Hoeltgen <hoeltgen@b-tu.de>
!
! This program is free software: you can redistribute it and/or modify it under
! the terms of the GNU General Public License as published by the Free Software
! Foundation, either version 3 of the License, or (at your option) any later
! version.
!
! This program is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
! FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License along with
! this program. If not, see <http://www.gnu.org/licenses/>.
!

#:setvar ikinds [ 'INT32',  'INT64' ]
#:setvar rkinds [ 'REAL32', 'REAL64' ]
#:setvar akinds [ 'INT32',  'INT64', 'REAL32', 'REAL64' ]
module miscfun
    use :: iso_fortran_env
    implicit none
    save
    private

    integer(INT32), parameter, private :: NPAR = 8  ! Used for allowing parallelisation of certain routines.

    public :: cumsum
    interface cumsum
#:for type in akinds
        module procedure cumsum_${type}$
#:endfor
    end interface cumsum

    public :: cumprod
    interface cumprod
#:for type in akinds
        module procedure cumprod_${type}$
#:endfor
    end interface cumprod

    public :: outerproduct
    interface outerproduct
#:for type in akinds
        module procedure outerproduct_${type}$
#:endfor
    end interface outerproduct

    public :: scatter_add
    interface scatter_add
#:for type in ikinds
        module procedure scatter_add_${type}$
#:endfor
#:for rtype in rkinds
#:for itype in ikinds
        module procedure scatter_add_${rtype}$_${itype}$
#:endfor
#:endfor
    end interface scatter_add

    public repelem
    interface repelem
#:for type in ikinds
        module procedure repelem_${type}$
#:endfor
#:for rtype in rkinds
#:for itype in ikinds
        module procedure repelem_${rtype}$_${itype}$
#:endfor
#:endfor
    end interface repelem

    public softshrinkage
    interface softshrinkage
#:for type in rkinds
        module procedure softshrinkage_${type}$
        module procedure softshrinkage_c_${type}$
#:endfor
#:for rtype in rkinds
#:for itype in ikinds
        module procedure softshrinkage_${rtype}$_${itype}$
        module procedure softshrinkage_c_${rtype}$_${itype}$
#:endfor
#:endfor            
    end interface softshrinkage

    public huberloss
    interface huberloss
#:for type in rkinds
        module procedure huberloss_${type}$
#:endfor
#:for rtype in rkinds
#:for itype in ikinds
        module procedure huberloss_${rtype}$_${itype}$
#:endfor
#:endfor            
    end interface huberloss

    public chop
    interface chop
#:for type in rkinds
        module procedure chop_${type}$
#:endfor
#:for rtype in rkinds
#:for itype in ikinds
        module procedure chop_${rtype}$_${itype}$
#:endfor
#:endfor            
    end interface chop

    public binarise
    interface binarise
#:for type in rkinds
        module procedure binarise_${type}$
#:endfor
#:for rtype in rkinds
#:for itype in ikinds
        module procedure binarise_${rtype}$_${itype}$
#:endfor
#:endfor            
    end interface binarise

contains

    !! Cumulative sum of an array
#:for type in ikinds
    pure recursive function cumsum_${type}$ (arr) result(ans)

        integer(${type}$), dimension(:), intent(in) :: arr

        integer(${type}$), dimension(size(arr)) :: ans

        integer(INT32) :: n, j

        n = size(arr)

        ans(1) = arr(1)

        if (n < NPAR) then
            do j = 2, n
                ans(j) = ans(j-1) + arr(j)
            end do
        else
            ans(2:n:2) = cumsum(arr(2:n:2) + arr(1:n-1:2))
            ans(3:n:2) = ans(2:n-1:2) + arr(3:n:2)
        end if
    end function cumsum_${type}$

#:endfor

#:for type in rkinds
    pure recursive function cumsum_${type}$ (arr) result(ans)

        real(${type}$), dimension(:), intent(in) :: arr

        real(${type}$), dimension(size(arr)) :: ans

        integer(INT32) :: n, j

        n = size(arr)

        ans(1) = arr(1)

        if (n < NPAR) then
            do j = 2, n
                ans(j) = ans(j-1) + arr(j)
            end do
        else
            ans(2:n:2) = cumsum(arr(2:n:2) + arr(1:n-1:2))
            ans(3:n:2) = ans(2:n-1:2) + arr(3:n:2)
        end if
    end function cumsum_${type}$

#:endfor

    !! Cumulative product of an array
#:for type in ikinds
    pure recursive function cumprod_${type}$ (arr) result(ans)

        integer(${type}$), dimension(:), intent(in) :: arr

        integer(${type}$), dimension(size(arr)) :: ans

        integer(INT32) :: n, j

        n = size(arr)

        ans(1) = arr(1)

        if (n < NPAR) then
            do j = 2, n
                ans(j) = ans(j-1) * arr(j)
            end do
        else
            ans(2:n:2) = cumprod (arr(2:n:2) * arr(1:n-1:2))
            ans(3:n:2) = ans(2:n-1:2) * arr(3:n:2)
        end if
    end function cumprod_${type}$

#:endfor

#:for type in rkinds
    pure recursive function cumprod_${type}$ (arr) result(ans)

        real(${type}$), dimension(:), intent(in) :: arr

        real(${type}$), dimension(size(arr)) :: ans

        integer(INT32) :: n, j

        n = size(arr)

        ans(1) = arr(1)

        if (n < NPAR) then
            do j = 2, n
                ans(j) = ans(j-1) * arr(j)
            end do
        else
            ans(2:n:2) = cumprod (arr(2:n:2) * arr(1:n-1:2))
            ans(3:n:2) = ans(2:n-1:2) * arr(3:n:2)
        end if
    end function cumprod_${type}$

#:endfor


    !! Outer product
#:for type in ikinds
    pure function outerproduct_${type}$ (a, b) result(ans)

        integer(${type}$), dimension(:), intent(in) :: a
        integer(${type}$), dimension(:), intent(in) :: b

        integer(${type}$), dimension(size(a),size(b)) :: ans

        ans = spread(a, dim=2, ncopies=size(b)) * spread(b, dim=1, ncopies=size(a))
    end function outerproduct_${type}$

#:endfor

#:for type in rkinds
    pure function outerproduct_${type}$ (a, b) result(ans)

        real(${type}$), dimension(:), intent(in) :: a
        real(${type}$), dimension(:), intent(in) :: b

        real(${type}$), dimension(size(a),size(b)) :: ans

        ans = spread(a, dim=2, ncopies=size(b)) * spread(b, dim=1, ncopies=size(a))
    end function outerproduct_${type}$

#:endfor

    !! Scatter Add
#:for type in ikinds
    pure subroutine scatter_add_${type}$ (source, dest_index, dest)

        integer(${type}$), dimension(:),            intent(in) :: source
        integer(${type}$), dimension(size(source)), intent(in) :: dest_index

        integer(${type}$), dimension(:), intent(out) :: dest

        integer(${type}$) :: m, n, j, i

        n=size(source)
        m=size(dest)
        do j=1, n
            i=dest_index(j)
            if (i > 0 .and. i <= m) dest(i) = dest(i) + source(j)
        end do
    end subroutine scatter_add_${type}$

#:endfor

#:for rtype in rkinds
#:for itype in ikinds
    pure subroutine scatter_add_${rtype}$_${itype}$ (source, dest_index, dest)

        real(${rtype}$), dimension(:),            intent(in) :: source
        integer(${itype}$), dimension(size(source)), intent(in) :: dest_index

        real(${rtype}$), dimension(:), intent(out) :: dest

        integer(${itype}$) :: m, n, j, i

        n=size(source)
        m=size(dest)
        do j=1, n
            i=dest_index(j)
            if (i > 0 .and. i <= m) dest(i) = dest(i) + source(j)
        end do
    end subroutine scatter_add_${rtype}$_${itype}$

#:endfor
#:endfor

#:for type in ikinds
    pure function repelem_${type}$ (src, ncop) result(dest)
        use :: constants
        implicit none

        integer(${type}$), dimension(:), intent(in) :: src
        integer(${type}$),               intent(in) :: ncop

        integer(${type}$), dimension(ncop*size(src)) :: dest

        dest = reshape(spread(src, I${type}$, ncop), [ncop*size(src)])

    end function repelem_${type}$

#:endfor

#:for rtype in rkinds
#:for itype in ikinds
    pure function repelem_${rtype}$_${itype}$ (src, ncop) result(dest)
        use :: constants
        implicit none

        real(${rtype}$), dimension(:), intent(in) :: src
        integer(${itype}$),               intent(in) :: ncop

        real(${rtype}$), dimension(ncop*size(src)) :: dest

        dest = reshape(spread(src, I${itype}$, ncop), [ncop*size(src)])

    end function repelem_${rtype}$_${itype}$

#:endfor
#:endfor

#:for rtype in rkinds
#:for itype in ikinds
    pure function softshrinkage_${rtype}$_${itype}$ (num, src, lambda) result(dest)
        use :: constants
        implicit none

        integer(${itype}$),              intent(in) :: num
        real(${rtype}$), dimension(num), intent(in) :: src
        real(${rtype}$),                 intent(in) :: lambda

        real(${rtype}$), dimension(num) :: dest

        integer(${itype}$) :: ii

        !$omp parallel do private( ii ) 
        do ii = 1, num
            if ( src(ii) > lambda) then
                dest(ii) = src(ii) - lambda
            else if (src(ii) < -I${rtype}$ * lambda) then
                dest(ii) = src(ii) + lambda
            else
                dest(ii) = Z${rtype}$
            end if
        end do
        !$omp end parallel do

    end function softshrinkage_${rtype}$_${itype}$

    pure function softshrinkage_c_${rtype}$_${itype}$ (num, src, lambda) result(dest)
        use :: constants
        implicit none

        integer(${itype}$),              intent(in) :: num
        complex(${rtype}$), dimension(num), intent(in) :: src
        real(${rtype}$),                 intent(in) :: lambda

        complex(${rtype}$), dimension(num) :: dest

        dest = cmplx (softshrinkage_${rtype}$_${itype}$ (num, real(src), lambda), \
        softshrinkage_${rtype}$_${itype}$ (num, aimag(src), lambda), ${rtype}$)

    end function softshrinkage_c_${rtype}$_${itype}$

#:endfor
#:endfor

#:for rtype in rkinds
    pure elemental function softshrinkage_${rtype}$ (src, lambda) result(dest)
        implicit none

        real(${rtype}$), intent(in) :: src
        real(${rtype}$), intent(in) :: lambda

        real(${rtype}$)             :: dest

        dest = sign(dim(abs(src), abs(lambda)), src)
    end function softshrinkage_${rtype}$

    pure elemental function softshrinkage_c_${rtype}$ (src, lambda) result(dest)
        use :: constants
        implicit none

        complex(${rtype}$), intent(in) :: src
        real(${rtype}$), intent(in) :: lambda

        complex(${rtype}$)             :: dest

        dest = cmplx (softshrinkage_${rtype}$(real(src), lambda), \
        softshrinkage_${rtype}$(aimag(src), lambda), ${rtype}$)
    end function softshrinkage_c_${rtype}$

#:endfor        

#:for rtype in rkinds
#:for itype in ikinds
    pure function huberloss_${rtype}$_${itype}$ (num, src, lambda) result(dest)
        use :: constants
        implicit none

        integer(${itype}$),              intent(in) :: num
        real(${rtype}$), dimension(num), intent(in) :: src
        real(${rtype}$),                 intent(in) :: lambda

        real(${rtype}$), dimension(num) :: dest

        integer(${itype}$) :: ii

        !$omp parallel do private( ii ) 
        do ii = 1, num
            if (abs(src(ii))<=abs(lambda)) then
                dest(ii) = H${rtype}$*src(ii)**2
            else
                dest(ii) = abs(lambda)*(abs(src(ii))-H${rtype}$*abs(lambda))
            end if

        end do
        !$omp end parallel do

    end function huberloss_${rtype}$_${itype}$

#:endfor
#:endfor

#:for rtype in rkinds
    pure elemental function huberloss_${rtype}$ (src, lambda) result(dest)
        use :: constants
        implicit none

        real(${rtype}$), intent(in) :: src
        real(${rtype}$), intent(in) :: lambda

        real(${rtype}$)             :: dest

        if (abs(src)<=abs(lambda)) then
            dest = H${rtype}$*src**2
        else
            dest = abs(lambda)*(abs(src)-H${rtype}$*abs(lambda))
        end if
    end function huberloss_${rtype}$

#:endfor

#:for rtype in rkinds
#:for itype in ikinds
    pure function chop_${rtype}$_${itype}$ (num, src, min_val, max_val) result(dest)
        use :: constants
        implicit none

        integer(${itype}$),              intent(in) :: num
        real(${rtype}$), dimension(num), intent(in) :: src
        real(${rtype}$),                 intent(in) :: min_val
        real(${rtype}$),                 intent(in) :: max_val

        real(${rtype}$), dimension(num) :: dest

        integer(${itype}$) :: ii

        !$omp parallel do private( ii ) 
        do ii = 1, num
            if (src(ii) < min_val) then
                dest(ii) = min_val
            elseif (src(ii) > max_val) then
                dest(ii) = max_val
            else
                dest(ii) = src(ii)
            end if
        end do
        !$omp end parallel do

    end function chop_${rtype}$_${itype}$

#:endfor
#:endfor
        
#:for rtype in rkinds
    pure elemental function chop_${rtype}$ (src, min_val, max_val) result(dest)
        use :: constants
        implicit none

        real(${rtype}$), intent(in) :: src
        real(${rtype}$), intent(in) :: min_val
        real(${rtype}$), intent(in) :: max_val

        real(${rtype}$)             :: dest

        dest = min ( max (src, min_val), max_val)
    end function chop_${rtype}$

#:endfor

#:for rtype in rkinds
#:for itype in ikinds
    pure function binarise_${rtype}$_${itype}$ (num, src, lambda) result(dest)
        use :: constants
        implicit none

        integer(${itype}$),              intent(in) :: num
        real(${rtype}$), dimension(num), intent(in) :: src
        real(${rtype}$),                 intent(in) :: lambda

        real(${rtype}$), dimension(num) :: dest

        integer(${itype}$) :: ii

        !$omp parallel do private( ii ) 
        do ii = 1, num
            if (src(ii) < lambda) then
                dest(ii) = Z${rtype}$
            else
                dest(ii) = I${rtype}$
            end if
        end do
        !$omp end parallel do

    end function binarise_${rtype}$_${itype}$

#:endfor
#:endfor
    
#:for rtype in rkinds
    pure elemental function binarise_${rtype}$ (src, lambda) result(dest)
        use :: constants
        implicit none

        real(${rtype}$), intent(in) :: src
        real(${rtype}$), intent(in) :: lambda

        real(${rtype}$)             :: dest

        dest = (sign (I${rtype}$, src-lambda) + ${rtype}$) * H${rtype}$
    end function binarise_${rtype}$

#:endfor


end module miscfun
